
 /----------------------------------------------------------------------------\
 |                                                                            |
 |  yosys -- Yosys Open SYnthesis Suite                                       |
 |                                                                            |
 |  Copyright (C) 2012 - 2020  Claire Xenia Wolf <claire@yosyshq.com>         |
 |                                                                            |
 |  Permission to use, copy, modify, and/or distribute this software for any  |
 |  purpose with or without fee is hereby granted, provided that the above    |
 |  copyright notice and this permission notice appear in all copies.         |
 |                                                                            |
 |  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES  |
 |  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF          |
 |  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR   |
 |  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES    |
 |  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN     |
 |  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF   |
 |  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.            |
 |                                                                            |
 \----------------------------------------------------------------------------/

 Yosys 0.36+3 (git sha1 a53032104, aarch64-apple-darwin20.2-clang 10.0.0-4ubuntu1 -fPIC -Os)


-- Running command `read_verilog -sv d11_zhexic_i2cdriver/src/toplevel_chip.v d11_zhexic_i2cdriver/src/chip.sv; synth -flatten -top toplevel_chip; setundef -undriven -zero; setundef -zero; async2sync; synth -top toplevel_chip; rename toplevel_chip d11_zhexic_i2cdriver; write_verilog -attr2comment d11_zhexic_i2cdriver/flattened.v; check; stat;' --

1. Executing Verilog-2005 frontend: d11_zhexic_i2cdriver/src/toplevel_chip.v
Parsing SystemVerilog input from `d11_zhexic_i2cdriver/src/toplevel_chip.v' to AST representation.
Generating RTLIL representation for module `\toplevel_chip'.
Successfully finished Verilog frontend.

2. Executing Verilog-2005 frontend: d11_zhexic_i2cdriver/src/chip.sv
Parsing SystemVerilog input from `d11_zhexic_i2cdriver/src/chip.sv' to AST representation.
Generating RTLIL representation for module `\my_chip'.
Generating RTLIL representation for module `\I2C_slave'.
Generating RTLIL representation for module `\SIPO'.
Generating RTLIL representation for module `\PISO'.
Generating RTLIL representation for module `\Register'.
Successfully finished Verilog frontend.

3. Executing SYNTH pass.

3.1. Executing HIERARCHY pass (managing design hierarchy).

3.1.1. Analyzing design hierarchy..
Top module:  \toplevel_chip
Used module:     \my_chip
Used module:         \I2C_slave
Used module:             \PISO
Used module:             \Register
Used module:             \SIPO

3.1.2. Analyzing design hierarchy..
Top module:  \toplevel_chip
Used module:     \my_chip
Used module:         \I2C_slave
Used module:             \PISO
Used module:             \Register
Used module:             \SIPO
Removed 0 unused modules.

3.2. Executing PROC pass (convert processes to netlists).

3.2.1. Executing PROC_CLEAN pass (remove empty switches from decision trees).
Cleaned up 0 empty switches.

3.2.2. Executing PROC_RMDEAD pass (remove dead branches from decision trees).
Marked 1 switch rules as full_case in process $proc$d11_zhexic_i2cdriver/src/chip.sv:485$54 in module Register.
Marked 2 switch rules as full_case in process $proc$d11_zhexic_i2cdriver/src/chip.sv:456$52 in module PISO.
Marked 1 switch rules as full_case in process $proc$d11_zhexic_i2cdriver/src/chip.sv:418$43 in module SIPO.
Marked 1 switch rules as full_case in process $proc$d11_zhexic_i2cdriver/src/chip.sv:394$40 in module I2C_slave.
Marked 19 switch rules as full_case in process $proc$d11_zhexic_i2cdriver/src/chip.sv:0$21 in module I2C_slave.
Marked 1 switch rules as full_case in process $proc$d11_zhexic_i2cdriver/src/chip.sv:171$12 in module I2C_slave.
Removed 1 dead cases from process $proc$d11_zhexic_i2cdriver/src/chip.sv:0$9 in module I2C_slave.
Marked 4 switch rules as full_case in process $proc$d11_zhexic_i2cdriver/src/chip.sv:0$9 in module I2C_slave.
Removed 1 dead cases from process $proc$d11_zhexic_i2cdriver/src/chip.sv:0$5 in module I2C_slave.
Marked 4 switch rules as full_case in process $proc$d11_zhexic_i2cdriver/src/chip.sv:0$5 in module I2C_slave.
Removed 1 dead cases from process $proc$d11_zhexic_i2cdriver/src/chip.sv:0$3 in module I2C_slave.
Marked 3 switch rules as full_case in process $proc$d11_zhexic_i2cdriver/src/chip.sv:0$3 in module I2C_slave.
Removed 1 dead cases from process $proc$d11_zhexic_i2cdriver/src/chip.sv:0$1 in module I2C_slave.
Marked 3 switch rules as full_case in process $proc$d11_zhexic_i2cdriver/src/chip.sv:0$1 in module I2C_slave.
Removed a total of 4 dead cases.

3.2.3. Executing PROC_PRUNE pass (remove redundant assignments in processes).
Removed 5 redundant assignments.
Promoted 22 assignments to connections.

3.2.4. Executing PROC_INIT pass (extract init attributes).

3.2.5. Executing PROC_ARST pass (detect async resets in processes).
Found async reset \reset in `\Register.$proc$d11_zhexic_i2cdriver/src/chip.sv:485$54'.
Found async reset \reset in `\PISO.$proc$d11_zhexic_i2cdriver/src/chip.sv:456$52'.
Found async reset \reset in `\SIPO.$proc$d11_zhexic_i2cdriver/src/chip.sv:418$43'.
Found async reset \reset in `\I2C_slave.$proc$d11_zhexic_i2cdriver/src/chip.sv:394$40'.
Found async reset \reset in `\I2C_slave.$proc$d11_zhexic_i2cdriver/src/chip.sv:171$12'.

3.2.6. Executing PROC_ROM pass (convert switches to ROMs).
Converted 0 switches.
<suppressed ~39 debug messages>

3.2.7. Executing PROC_MUX pass (convert decision trees to multiplexers).
Creating decoders for process `\Register.$proc$d11_zhexic_i2cdriver/src/chip.sv:485$54'.
     1/1: $0\out[7:0]
Creating decoders for process `\PISO.$proc$d11_zhexic_i2cdriver/src/chip.sv:456$52'.
     1/3: $0\register[7:0]
     2/3: $0\counter[3:0]
     3/3: $0\out[0:0]
Creating decoders for process `\SIPO.$proc$d11_zhexic_i2cdriver/src/chip.sv:418$43'.
     1/2: $0\counter[3:0]
     2/2: $0\out[7:0]
Creating decoders for process `\I2C_slave.$proc$d11_zhexic_i2cdriver/src/chip.sv:394$40'.
     1/1: $0\state[3:0]
Creating decoders for process `\I2C_slave.$proc$d11_zhexic_i2cdriver/src/chip.sv:0$21'.
     1/47: $20\nextstate[3:0]
     2/47: $19\nextstate[3:0]
     3/47: $18\nextstate[3:0]
     4/47: $5\wr_up[0:0]
     5/47: $17\nextstate[3:0]
     6/47: $4\wr_up[0:0]
     7/47: $4\piso_spit[0:0]
     8/47: $16\nextstate[3:0]
     9/47: $3\wr_up[0:0]
    10/47: $3\piso_spit[0:0]
    11/47: $15\nextstate[3:0]
    12/47: $2\wr_up[0:0]
    13/47: $2\piso_spit[0:0]
    14/47: $7\ack[0:0]
    15/47: $14\nextstate[3:0]
    16/47: $6\ack[0:0]
    17/47: $13\nextstate[3:0]
    18/47: $12\nextstate[3:0]
    19/47: $3\store[0:0]
    20/47: $5\ack[0:0]
    21/47: $11\nextstate[3:0]
    22/47: $4\sipo_load[0:0]
    23/47: $4\ack[0:0]
    24/47: $2\store[0:0]
    25/47: $10\nextstate[3:0]
    26/47: $3\sipo_load[0:0]
    27/47: $9\nextstate[3:0]
    28/47: $3\sipo_clear[0:0]
    29/47: $3\ack[0:0]
    30/47: $8\nextstate[3:0]
    31/47: $2\ack[0:0]
    32/47: $7\nextstate[3:0]
    33/47: $6\nextstate[3:0]
    34/47: $5\nextstate[3:0]
    35/47: $4\nextstate[3:0]
    36/47: $3\nextstate[3:0]
    37/47: $2\sipo_load[0:0]
    38/47: $2\nextstate[3:0]
    39/47: $2\sipo_clear[0:0]
    40/47: $1\nextstate[3:0]
    41/47: $1\sipo_clear[0:0]
    42/47: $1\ack[0:0]
    43/47: $1\piso_spit[0:0]
    44/47: $1\store[0:0]
    45/47: $1\sipo_load[0:0]
    46/47: $1\wr_down[0:0]
    47/47: $1\wr_up[0:0]
Creating decoders for process `\I2C_slave.$proc$d11_zhexic_i2cdriver/src/chip.sv:171$12'.
     1/4: $0\stop_state[0:0]
     2/4: $0\start_state[0:0]
     3/4: $0\sda_state[0:0]
     4/4: $0\scl_state[0:0]
Creating decoders for process `\I2C_slave.$proc$d11_zhexic_i2cdriver/src/chip.sv:0$9'.
     1/6: $4\stop_nextstate[0:0]
     2/6: $3\stop_nextstate[0:0]
     3/6: $2\i2c_stop[0:0]
     4/6: $2\stop_nextstate[0:0]
     5/6: $1\stop_nextstate[0:0]
     6/6: $1\i2c_stop[0:0]
Creating decoders for process `\I2C_slave.$proc$d11_zhexic_i2cdriver/src/chip.sv:0$5'.
     1/6: $4\start_nextstate[0:0]
     2/6: $3\start_nextstate[0:0]
     3/6: $2\i2c_start[0:0]
     4/6: $2\start_nextstate[0:0]
     5/6: $1\start_nextstate[0:0]
     6/6: $1\i2c_start[0:0]
Creating decoders for process `\I2C_slave.$proc$d11_zhexic_i2cdriver/src/chip.sv:0$3'.
     1/13: $3\sda_nextstate[0:0]
     2/13: $3\sda_low[0:0]
     3/13: $2\sda_fall[0:0]
     4/13: $3\sda_high[0:0]
     5/13: $2\sda_nextstate[0:0]
     6/13: $2\sda_high[0:0]
     7/13: $2\sda_rise[0:0]
     8/13: $2\sda_low[0:0]
     9/13: $1\sda_low[0:0]
    10/13: $1\sda_high[0:0]
    11/13: $1\sda_rise[0:0]
    12/13: $1\sda_nextstate[0:0]
    13/13: $1\sda_fall[0:0]
Creating decoders for process `\I2C_slave.$proc$d11_zhexic_i2cdriver/src/chip.sv:0$1'.
     1/13: $3\scl_nextstate[0:0]
     2/13: $3\scl_low[0:0]
     3/13: $2\scl_fall[0:0]
     4/13: $3\scl_high[0:0]
     5/13: $2\scl_nextstate[0:0]
     6/13: $2\scl_high[0:0]
     7/13: $2\scl_rise[0:0]
     8/13: $2\scl_low[0:0]
     9/13: $1\scl_low[0:0]
    10/13: $1\scl_high[0:0]
    11/13: $1\scl_rise[0:0]
    12/13: $1\scl_nextstate[0:0]
    13/13: $1\scl_fall[0:0]

3.2.8. Executing PROC_DLATCH pass (convert process syncs to latches).
No latch inferred for signal `\I2C_slave.\wr_up' from process `\I2C_slave.$proc$d11_zhexic_i2cdriver/src/chip.sv:0$21'.
No latch inferred for signal `\I2C_slave.\wr_down' from process `\I2C_slave.$proc$d11_zhexic_i2cdriver/src/chip.sv:0$21'.
No latch inferred for signal `\I2C_slave.\sipo_load' from process `\I2C_slave.$proc$d11_zhexic_i2cdriver/src/chip.sv:0$21'.
No latch inferred for signal `\I2C_slave.\sipo_clear' from process `\I2C_slave.$proc$d11_zhexic_i2cdriver/src/chip.sv:0$21'.
No latch inferred for signal `\I2C_slave.\store' from process `\I2C_slave.$proc$d11_zhexic_i2cdriver/src/chip.sv:0$21'.
No latch inferred for signal `\I2C_slave.\piso_spit' from process `\I2C_slave.$proc$d11_zhexic_i2cdriver/src/chip.sv:0$21'.
No latch inferred for signal `\I2C_slave.\ack' from process `\I2C_slave.$proc$d11_zhexic_i2cdriver/src/chip.sv:0$21'.
No latch inferred for signal `\I2C_slave.\nextstate' from process `\I2C_slave.$proc$d11_zhexic_i2cdriver/src/chip.sv:0$21'.
No latch inferred for signal `\I2C_slave.\stop_nextstate' from process `\I2C_slave.$proc$d11_zhexic_i2cdriver/src/chip.sv:0$9'.
No latch inferred for signal `\I2C_slave.\i2c_stop' from process `\I2C_slave.$proc$d11_zhexic_i2cdriver/src/chip.sv:0$9'.
No latch inferred for signal `\I2C_slave.\start_nextstate' from process `\I2C_slave.$proc$d11_zhexic_i2cdriver/src/chip.sv:0$5'.
No latch inferred for signal `\I2C_slave.\i2c_start' from process `\I2C_slave.$proc$d11_zhexic_i2cdriver/src/chip.sv:0$5'.
No latch inferred for signal `\I2C_slave.\sda_nextstate' from process `\I2C_slave.$proc$d11_zhexic_i2cdriver/src/chip.sv:0$3'.
No latch inferred for signal `\I2C_slave.\sda_rise' from process `\I2C_slave.$proc$d11_zhexic_i2cdriver/src/chip.sv:0$3'.
No latch inferred for signal `\I2C_slave.\sda_fall' from process `\I2C_slave.$proc$d11_zhexic_i2cdriver/src/chip.sv:0$3'.
No latch inferred for signal `\I2C_slave.\sda_high' from process `\I2C_slave.$proc$d11_zhexic_i2cdriver/src/chip.sv:0$3'.
No latch inferred for signal `\I2C_slave.\sda_low' from process `\I2C_slave.$proc$d11_zhexic_i2cdriver/src/chip.sv:0$3'.
No latch inferred for signal `\I2C_slave.\scl_nextstate' from process `\I2C_slave.$proc$d11_zhexic_i2cdriver/src/chip.sv:0$1'.
No latch inferred for signal `\I2C_slave.\scl_rise' from process `\I2C_slave.$proc$d11_zhexic_i2cdriver/src/chip.sv:0$1'.
No latch inferred for signal `\I2C_slave.\scl_fall' from process `\I2C_slave.$proc$d11_zhexic_i2cdriver/src/chip.sv:0$1'.
No latch inferred for signal `\I2C_slave.\scl_high' from process `\I2C_slave.$proc$d11_zhexic_i2cdriver/src/chip.sv:0$1'.
No latch inferred for signal `\I2C_slave.\scl_low' from process `\I2C_slave.$proc$d11_zhexic_i2cdriver/src/chip.sv:0$1'.

3.2.9. Executing PROC_DFF pass (convert process syncs to FFs).
Creating register for signal `\Register.\out' using process `\Register.$proc$d11_zhexic_i2cdriver/src/chip.sv:485$54'.
  created $adff cell `$procdff$811' with positive edge clock and negative level reset.
Creating register for signal `\PISO.\out' using process `\PISO.$proc$d11_zhexic_i2cdriver/src/chip.sv:456$52'.
  created $adff cell `$procdff$812' with positive edge clock and negative level reset.
Creating register for signal `\PISO.\counter' using process `\PISO.$proc$d11_zhexic_i2cdriver/src/chip.sv:456$52'.
  created $adff cell `$procdff$813' with positive edge clock and negative level reset.
Creating register for signal `\PISO.\register' using process `\PISO.$proc$d11_zhexic_i2cdriver/src/chip.sv:456$52'.
  created $adff cell `$procdff$814' with positive edge clock and negative level reset.
Creating register for signal `\SIPO.\out' using process `\SIPO.$proc$d11_zhexic_i2cdriver/src/chip.sv:418$43'.
  created $adff cell `$procdff$815' with positive edge clock and negative level reset.
Creating register for signal `\SIPO.\counter' using process `\SIPO.$proc$d11_zhexic_i2cdriver/src/chip.sv:418$43'.
  created $adff cell `$procdff$816' with positive edge clock and negative level reset.
Creating register for signal `\I2C_slave.\state' using process `\I2C_slave.$proc$d11_zhexic_i2cdriver/src/chip.sv:394$40'.
  created $adff cell `$procdff$817' with positive edge clock and negative level reset.
Creating register for signal `\I2C_slave.\scl_state' using process `\I2C_slave.$proc$d11_zhexic_i2cdriver/src/chip.sv:171$12'.
  created $adff cell `$procdff$818' with positive edge clock and negative level reset.
Creating register for signal `\I2C_slave.\sda_state' using process `\I2C_slave.$proc$d11_zhexic_i2cdriver/src/chip.sv:171$12'.
  created $adff cell `$procdff$819' with positive edge clock and negative level reset.
Creating register for signal `\I2C_slave.\start_state' using process `\I2C_slave.$proc$d11_zhexic_i2cdriver/src/chip.sv:171$12'.
  created $adff cell `$procdff$820' with positive edge clock and negative level reset.
Creating register for signal `\I2C_slave.\stop_state' using process `\I2C_slave.$proc$d11_zhexic_i2cdriver/src/chip.sv:171$12'.
  created $adff cell `$procdff$821' with positive edge clock and negative level reset.

3.2.10. Executing PROC_MEMWR pass (convert process memory writes to cells).

3.2.11. Executing PROC_CLEAN pass (remove empty switches from decision trees).
Found and cleaned up 1 empty switch in `\Register.$proc$d11_zhexic_i2cdriver/src/chip.sv:485$54'.
Removing empty process `Register.$proc$d11_zhexic_i2cdriver/src/chip.sv:485$54'.
Found and cleaned up 2 empty switches in `\PISO.$proc$d11_zhexic_i2cdriver/src/chip.sv:456$52'.
Removing empty process `PISO.$proc$d11_zhexic_i2cdriver/src/chip.sv:456$52'.
Found and cleaned up 2 empty switches in `\SIPO.$proc$d11_zhexic_i2cdriver/src/chip.sv:418$43'.
Removing empty process `SIPO.$proc$d11_zhexic_i2cdriver/src/chip.sv:418$43'.
Removing empty process `I2C_slave.$proc$d11_zhexic_i2cdriver/src/chip.sv:394$40'.
Found and cleaned up 20 empty switches in `\I2C_slave.$proc$d11_zhexic_i2cdriver/src/chip.sv:0$21'.
Removing empty process `I2C_slave.$proc$d11_zhexic_i2cdriver/src/chip.sv:0$21'.
Removing empty process `I2C_slave.$proc$d11_zhexic_i2cdriver/src/chip.sv:171$12'.
Found and cleaned up 4 empty switches in `\I2C_slave.$proc$d11_zhexic_i2cdriver/src/chip.sv:0$9'.
Removing empty process `I2C_slave.$proc$d11_zhexic_i2cdriver/src/chip.sv:0$9'.
Found and cleaned up 4 empty switches in `\I2C_slave.$proc$d11_zhexic_i2cdriver/src/chip.sv:0$5'.
Removing empty process `I2C_slave.$proc$d11_zhexic_i2cdriver/src/chip.sv:0$5'.
Found and cleaned up 3 empty switches in `\I2C_slave.$proc$d11_zhexic_i2cdriver/src/chip.sv:0$3'.
Removing empty process `I2C_slave.$proc$d11_zhexic_i2cdriver/src/chip.sv:0$3'.
Found and cleaned up 3 empty switches in `\I2C_slave.$proc$d11_zhexic_i2cdriver/src/chip.sv:0$1'.
Removing empty process `I2C_slave.$proc$d11_zhexic_i2cdriver/src/chip.sv:0$1'.
Cleaned up 39 empty switches.

3.2.12. Executing OPT_EXPR pass (perform const folding).
Optimizing module Register.
Optimizing module PISO.
Optimizing module SIPO.
Optimizing module I2C_slave.
<suppressed ~74 debug messages>
Optimizing module my_chip.
Optimizing module toplevel_chip.

3.3. Executing FLATTEN pass (flatten design).
Deleting now unused module Register.
Deleting now unused module PISO.
Deleting now unused module SIPO.
Deleting now unused module I2C_slave.
Deleting now unused module my_chip.
<suppressed ~5 debug messages>

3.4. Executing OPT_EXPR pass (perform const folding).
Optimizing module toplevel_chip.

3.5. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \toplevel_chip..
Removed 23 unused cells and 288 unused wires.
<suppressed ~25 debug messages>

3.6. Executing CHECK pass (checking for obvious problems).
Checking module toplevel_chip...
Found and reported 0 problems.

3.7. Executing OPT pass (performing simple optimizations).

3.7.1. Executing OPT_EXPR pass (perform const folding).
Optimizing module toplevel_chip.

3.7.2. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\toplevel_chip'.
<suppressed ~219 debug messages>
Removed a total of 73 cells.

3.7.3. Executing OPT_MUXTREE pass (detect dead branches in mux trees).
Running muxtree optimizer on module \toplevel_chip..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
    dead port 2/2 on $mux $flatten\mchip.\slv.$procmux$215.
    dead port 1/2 on $mux $flatten\mchip.\slv.$procmux$227.
    dead port 1/2 on $mux $flatten\mchip.\slv.$procmux$230.
    dead port 2/2 on $mux $flatten\mchip.\slv.$procmux$232.
    dead port 1/2 on $mux $flatten\mchip.\slv.$procmux$244.
    dead port 2/2 on $mux $flatten\mchip.\slv.$procmux$246.
    dead port 1/2 on $mux $flatten\mchip.\slv.$procmux$258.
    dead port 2/2 on $mux $flatten\mchip.\slv.$procmux$260.
    dead port 1/2 on $mux $flatten\mchip.\slv.$procmux$272.
    dead port 2/2 on $mux $flatten\mchip.\slv.$procmux$274.
    dead port 2/2 on $mux $flatten\mchip.\slv.$procmux$285.
    dead port 2/2 on $mux $flatten\mchip.\slv.$procmux$296.
    dead port 2/2 on $mux $flatten\mchip.\slv.$procmux$307.
    dead port 2/2 on $mux $flatten\mchip.\slv.$procmux$318.
    dead port 2/2 on $mux $flatten\mchip.\slv.$procmux$330.
    dead port 2/2 on $mux $flatten\mchip.\slv.$procmux$342.
    dead port 2/2 on $mux $flatten\mchip.\slv.$procmux$355.
    dead port 2/2 on $mux $flatten\mchip.\slv.$procmux$368.
    dead port 2/2 on $mux $flatten\mchip.\slv.$procmux$381.
    dead port 2/2 on $mux $flatten\mchip.\slv.$procmux$395.
    dead port 2/2 on $mux $flatten\mchip.\slv.$procmux$409.
    dead port 2/2 on $mux $flatten\mchip.\slv.$procmux$424.
    dead port 1/2 on $mux $flatten\mchip.\slv.$procmux$441.
    dead port 1/2 on $mux $flatten\mchip.\slv.$procmux$444.
    dead port 1/2 on $mux $flatten\mchip.\slv.$procmux$447.
    dead port 2/2 on $mux $flatten\mchip.\slv.$procmux$449.
    dead port 1/2 on $mux $flatten\mchip.\slv.$procmux$466.
    dead port 1/2 on $mux $flatten\mchip.\slv.$procmux$469.
    dead port 2/2 on $mux $flatten\mchip.\slv.$procmux$471.
    dead port 1/2 on $mux $flatten\mchip.\slv.$procmux$488.
    dead port 2/2 on $mux $flatten\mchip.\slv.$procmux$490.
    dead port 2/2 on $mux $flatten\mchip.\slv.$procmux$506.
    dead port 2/2 on $mux $flatten\mchip.\slv.$procmux$522.
    dead port 2/2 on $mux $flatten\mchip.\slv.$procmux$539.
    dead port 2/2 on $mux $flatten\mchip.\slv.$procmux$556.
    dead port 1/2 on $mux $flatten\mchip.\slv.$procmux$102.
    dead port 2/2 on $mux $flatten\mchip.\slv.$procmux$104.
    dead port 1/2 on $mux $flatten\mchip.\slv.$procmux$112.
    dead port 2/2 on $mux $flatten\mchip.\slv.$procmux$114.
    dead port 2/2 on $mux $flatten\mchip.\slv.$procmux$121.
    dead port 2/2 on $mux $flatten\mchip.\slv.$procmux$128.
    dead port 2/2 on $mux $flatten\mchip.\slv.$procmux$135.
    dead port 2/2 on $mux $flatten\mchip.\slv.$procmux$143.
    dead port 2/2 on $mux $flatten\mchip.\slv.$procmux$151.
    dead port 2/2 on $mux $flatten\mchip.\slv.$procmux$159.
    dead port 2/2 on $mux $flatten\mchip.\slv.$procmux$205.
    dead port 2/2 on $mux $flatten\mchip.\slv.$procmux$168.
    dead port 1/2 on $mux $flatten\mchip.\slv.$procmux$637.
    dead port 2/2 on $mux $flatten\mchip.\slv.$procmux$639.
    dead port 2/2 on $mux $flatten\mchip.\slv.$procmux$644.
    dead port 2/2 on $mux $flatten\mchip.\slv.$procmux$649.
    dead port 1/2 on $mux $flatten\mchip.\slv.$procmux$655.
    dead port 1/2 on $mux $flatten\mchip.\slv.$procmux$667.
    dead port 2/2 on $mux $flatten\mchip.\slv.$procmux$669.
    dead port 2/2 on $mux $flatten\mchip.\slv.$procmux$674.
    dead port 2/2 on $mux $flatten\mchip.\slv.$procmux$679.
    dead port 1/2 on $mux $flatten\mchip.\slv.$procmux$685.
    dead port 2/2 on $mux $flatten\mchip.\slv.$procmux$696.
    dead port 2/2 on $mux $flatten\mchip.\slv.$procmux$701.
    dead port 2/2 on $mux $flatten\mchip.\slv.$procmux$706.
    dead port 2/2 on $mux $flatten\mchip.\slv.$procmux$711.
    dead port 1/2 on $mux $flatten\mchip.\slv.$procmux$717.
    dead port 1/2 on $mux $flatten\mchip.\slv.$procmux$723.
    dead port 1/2 on $mux $flatten\mchip.\slv.$procmux$729.
    dead port 1/2 on $mux $flatten\mchip.\slv.$procmux$735.
    dead port 2/2 on $mux $flatten\mchip.\slv.$procmux$177.
    dead port 2/2 on $mux $flatten\mchip.\slv.$procmux$186.
    dead port 2/2 on $mux $flatten\mchip.\slv.$procmux$755.
    dead port 2/2 on $mux $flatten\mchip.\slv.$procmux$765.
    dead port 2/2 on $mux $flatten\mchip.\slv.$procmux$770.
    dead port 1/2 on $mux $flatten\mchip.\slv.$procmux$776.
    dead port 1/2 on $mux $flatten\mchip.\slv.$procmux$782.
    dead port 1/2 on $mux $flatten\mchip.\slv.$procmux$788.
    dead port 2/2 on $mux $flatten\mchip.\slv.$procmux$195.
    dead port 1/2 on $mux $flatten\mchip.\slv.$procmux$86.
    dead port 2/2 on $mux $flatten\mchip.\slv.$procmux$88.
    dead port 2/2 on $mux $flatten\mchip.\slv.$procmux$94.
Removed 77 multiplexer ports.
<suppressed ~28 debug messages>

3.7.4. Executing OPT_REDUCE pass (consolidate $*mux and $reduce_* inputs).
  Optimizing cells in module \toplevel_chip.
    New ctrl vector for $pmux cell $flatten\mchip.\slv.$procmux$623: $auto$opt_reduce.cc:134:opt_pmux$823
  Optimizing cells in module \toplevel_chip.
Performed a total of 1 changes.

3.7.5. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\toplevel_chip'.
<suppressed ~69 debug messages>
Removed a total of 23 cells.

3.7.6. Executing OPT_DFF pass (perform DFF optimizations).

3.7.7. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \toplevel_chip..
Removed 0 unused cells and 171 unused wires.
<suppressed ~1 debug messages>

3.7.8. Executing OPT_EXPR pass (perform const folding).
Optimizing module toplevel_chip.

3.7.9. Rerunning OPT passes. (Maybe there is more to do..)

3.7.10. Executing OPT_MUXTREE pass (detect dead branches in mux trees).
Running muxtree optimizer on module \toplevel_chip..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Removed 0 multiplexer ports.
<suppressed ~32 debug messages>

3.7.11. Executing OPT_REDUCE pass (consolidate $*mux and $reduce_* inputs).
  Optimizing cells in module \toplevel_chip.
    New ctrl vector for $pmux cell $flatten\mchip.\slv.$procmux$587: { $flatten\mchip.\slv.$procmux$233_CMP $auto$opt_reduce.cc:134:opt_pmux$827 $auto$opt_reduce.cc:134:opt_pmux$825 }
    New ctrl vector for $pmux cell $flatten\mchip.\slv.$procmux$595: { $auto$opt_reduce.cc:134:opt_pmux$829 $flatten\mchip.\slv.$procmux$105_CMP }
    New ctrl vector for $pmux cell $flatten\mchip.\slv.$procmux$613: { $flatten\mchip.\slv.$procmux$331_CMP $auto$opt_reduce.cc:134:opt_pmux$831 }
    New ctrl vector for $pmux cell $flatten\mchip.\slv.$procmux$629: { $auto$opt_reduce.cc:134:opt_pmux$833 $flatten\mchip.\slv.$procmux$105_CMP }
    New ctrl vector for $pmux cell $flatten\mchip.\slv.$procmux$737: $auto$opt_reduce.cc:134:opt_pmux$835
    New ctrl vector for $pmux cell $flatten\mchip.\slv.$procmux$740: $auto$opt_reduce.cc:134:opt_pmux$837
    New ctrl vector for $pmux cell $flatten\mchip.\slv.$procmux$799: $auto$opt_reduce.cc:134:opt_pmux$839
  Optimizing cells in module \toplevel_chip.
Performed a total of 7 changes.

3.7.12. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\toplevel_chip'.
<suppressed ~6 debug messages>
Removed a total of 2 cells.

3.7.13. Executing OPT_DFF pass (perform DFF optimizations).

3.7.14. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \toplevel_chip..
Removed 0 unused cells and 2 unused wires.
<suppressed ~1 debug messages>

3.7.15. Executing OPT_EXPR pass (perform const folding).
Optimizing module toplevel_chip.
<suppressed ~5 debug messages>

3.7.16. Rerunning OPT passes. (Maybe there is more to do..)

3.7.17. Executing OPT_MUXTREE pass (detect dead branches in mux trees).
Running muxtree optimizer on module \toplevel_chip..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Removed 0 multiplexer ports.
<suppressed ~29 debug messages>

3.7.18. Executing OPT_REDUCE pass (consolidate $*mux and $reduce_* inputs).
  Optimizing cells in module \toplevel_chip.
Performed a total of 0 changes.

3.7.19. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\toplevel_chip'.
Removed a total of 0 cells.

3.7.20. Executing OPT_DFF pass (perform DFF optimizations).

3.7.21. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \toplevel_chip..
Removed 0 unused cells and 5 unused wires.
<suppressed ~1 debug messages>

3.7.22. Executing OPT_EXPR pass (perform const folding).
Optimizing module toplevel_chip.

3.7.23. Rerunning OPT passes. (Maybe there is more to do..)

3.7.24. Executing OPT_MUXTREE pass (detect dead branches in mux trees).
Running muxtree optimizer on module \toplevel_chip..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Removed 0 multiplexer ports.
<suppressed ~29 debug messages>

3.7.25. Executing OPT_REDUCE pass (consolidate $*mux and $reduce_* inputs).
  Optimizing cells in module \toplevel_chip.
Performed a total of 0 changes.

3.7.26. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\toplevel_chip'.
Removed a total of 0 cells.

3.7.27. Executing OPT_DFF pass (perform DFF optimizations).

3.7.28. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \toplevel_chip..

3.7.29. Executing OPT_EXPR pass (perform const folding).
Optimizing module toplevel_chip.

3.7.30. Finished OPT passes. (There is nothing left to do.)

3.8. Executing FSM pass (extract and optimize FSM).

3.8.1. Executing FSM_DETECT pass (finding FSMs in design).
Not marking toplevel_chip.mchip.slv.state as FSM state register:
    Circuit seems to be self-resetting.

3.8.2. Executing FSM_EXTRACT pass (extracting FSM from design).

3.8.3. Executing FSM_OPT pass (simple optimizations of FSMs).

3.8.4. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \toplevel_chip..

3.8.5. Executing FSM_OPT pass (simple optimizations of FSMs).

3.8.6. Executing FSM_RECODE pass (re-assigning FSM state encoding).

3.8.7. Executing FSM_INFO pass (dumping all available information on FSM cells).

3.8.8. Executing FSM_MAP pass (mapping FSMs to basic logic).

3.9. Executing OPT pass (performing simple optimizations).

3.9.1. Executing OPT_EXPR pass (perform const folding).
Optimizing module toplevel_chip.

3.9.2. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\toplevel_chip'.
Removed a total of 0 cells.

3.9.3. Executing OPT_MUXTREE pass (detect dead branches in mux trees).
Running muxtree optimizer on module \toplevel_chip..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Removed 0 multiplexer ports.
<suppressed ~29 debug messages>

3.9.4. Executing OPT_REDUCE pass (consolidate $*mux and $reduce_* inputs).
  Optimizing cells in module \toplevel_chip.
Performed a total of 0 changes.

3.9.5. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\toplevel_chip'.
Removed a total of 0 cells.

3.9.6. Executing OPT_DFF pass (perform DFF optimizations).
Adding EN signal on $flatten\mchip.\slv.\the_sipo.$procdff$816 ($adff) from module toplevel_chip (D = $flatten\mchip.\slv.\the_sipo.$0\counter[3:0], Q = \mchip.slv.the_sipo.counter).
Adding EN signal on $flatten\mchip.\slv.\the_sipo.$procdff$815 ($adff) from module toplevel_chip (D = $flatten\mchip.\slv.\the_sipo.$0\out[7:0], Q = \mchip.slv.the_sipo.out).
Adding EN signal on $flatten\mchip.\slv.\the_reg.$procdff$811 ($adff) from module toplevel_chip (D = \mchip.slv.the_sipo.out, Q = \mchip.slv.the_reg.out).
Adding EN signal on $flatten\mchip.\slv.\the_piso.$procdff$814 ($adff) from module toplevel_chip (D = $flatten\mchip.\slv.\the_piso.$0\register[7:0], Q = \mchip.slv.the_piso.register).
Adding EN signal on $flatten\mchip.\slv.\the_piso.$procdff$813 ($adff) from module toplevel_chip (D = $flatten\mchip.\slv.\the_piso.$0\counter[3:0], Q = \mchip.slv.the_piso.counter).
Adding EN signal on $flatten\mchip.\slv.\the_piso.$procdff$812 ($adff) from module toplevel_chip (D = $flatten\mchip.\slv.\the_piso.$0\out[0:0], Q = \mchip.slv.the_piso.out).

3.9.7. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \toplevel_chip..
Removed 1 unused cells and 1 unused wires.
<suppressed ~2 debug messages>

3.9.8. Executing OPT_EXPR pass (perform const folding).
Optimizing module toplevel_chip.
<suppressed ~5 debug messages>

3.9.9. Rerunning OPT passes. (Maybe there is more to do..)

3.9.10. Executing OPT_MUXTREE pass (detect dead branches in mux trees).
Running muxtree optimizer on module \toplevel_chip..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Removed 0 multiplexer ports.
<suppressed ~28 debug messages>

3.9.11. Executing OPT_REDUCE pass (consolidate $*mux and $reduce_* inputs).
  Optimizing cells in module \toplevel_chip.
Performed a total of 0 changes.

3.9.12. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\toplevel_chip'.
<suppressed ~9 debug messages>
Removed a total of 3 cells.

3.9.13. Executing OPT_DFF pass (perform DFF optimizations).

3.9.14. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \toplevel_chip..
Removed 0 unused cells and 3 unused wires.
<suppressed ~1 debug messages>

3.9.15. Executing OPT_EXPR pass (perform const folding).
Optimizing module toplevel_chip.

3.9.16. Rerunning OPT passes. (Maybe there is more to do..)

3.9.17. Executing OPT_MUXTREE pass (detect dead branches in mux trees).
Running muxtree optimizer on module \toplevel_chip..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Removed 0 multiplexer ports.
<suppressed ~28 debug messages>

3.9.18. Executing OPT_REDUCE pass (consolidate $*mux and $reduce_* inputs).
  Optimizing cells in module \toplevel_chip.
Performed a total of 0 changes.

3.9.19. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\toplevel_chip'.
Removed a total of 0 cells.

3.9.20. Executing OPT_DFF pass (perform DFF optimizations).

3.9.21. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \toplevel_chip..

3.9.22. Executing OPT_EXPR pass (perform const folding).
Optimizing module toplevel_chip.

3.9.23. Finished OPT passes. (There is nothing left to do.)

3.10. Executing WREDUCE pass (reducing word size of cells).
Removed top 3 bits (of 4) from mux cell toplevel_chip.$flatten\mchip.\slv.$procmux$99 ($mux).
Removed top 3 bits (of 4) from mux cell toplevel_chip.$flatten\mchip.\slv.$procmux$119 ($mux).
Removed top 2 bits (of 4) from mux cell toplevel_chip.$flatten\mchip.\slv.$procmux$141 ($mux).
Removed top 3 bits (of 4) from mux cell toplevel_chip.$flatten\mchip.\slv.$procmux$166 ($mux).
Removed top 1 bits (of 4) from port B of cell toplevel_chip.$flatten\mchip.\slv.$procmux$206_CMP0 ($eq).
Removed top 1 bits (of 4) from mux cell toplevel_chip.$flatten\mchip.\slv.$procmux$224 ($mux).
Removed top 1 bits (of 4) from port B of cell toplevel_chip.$flatten\mchip.\slv.$procmux$233_CMP0 ($eq).
Removed top 1 bits (of 4) from mux cell toplevel_chip.$flatten\mchip.\slv.$procmux$241 ($mux).
Removed top 1 bits (of 4) from mux cell toplevel_chip.$flatten\mchip.\slv.$procmux$283 ($mux).
Removed top 2 bits (of 4) from mux cell toplevel_chip.$flatten\mchip.\slv.$procmux$328 ($mux).
Removed top 1 bits (of 4) from port B of cell toplevel_chip.$flatten\mchip.\slv.$procmux$331_CMP0 ($eq).
Removed top 3 bits (of 4) from mux cell toplevel_chip.$flatten\mchip.\slv.$procmux$353 ($mux).
Removed top 1 bits (of 4) from port B of cell toplevel_chip.$flatten\mchip.\slv.$procmux$356_CMP0 ($eq).
Removed top 1 bits (of 4) from mux cell toplevel_chip.$flatten\mchip.\slv.$procmux$393 ($mux).
Removed top 2 bits (of 4) from port B of cell toplevel_chip.$flatten\mchip.\slv.$procmux$396_CMP0 ($eq).
Removed top 2 bits (of 4) from mux cell toplevel_chip.$flatten\mchip.\slv.$procmux$422 ($mux).
Removed top 2 bits (of 4) from port B of cell toplevel_chip.$flatten\mchip.\slv.$procmux$425_CMP0 ($eq).
Removed top 1 bits (of 4) from mux cell toplevel_chip.$flatten\mchip.\slv.$procmux$438 ($mux).
Removed top 3 bits (of 4) from port B of cell toplevel_chip.$flatten\mchip.\slv.$procmux$450_CMP0 ($eq).
Removed top 1 bits (of 4) from mux cell toplevel_chip.$flatten\mchip.\slv.$procmux$463 ($mux).
Removed top 1 bits (of 4) from mux cell toplevel_chip.$flatten\mchip.\slv.$procmux$485 ($mux).
Removed top 1 bits (of 4) from mux cell toplevel_chip.$flatten\mchip.\slv.$procmux$504 ($mux).
Removed top 3 bits (of 4) from mux cell toplevel_chip.$flatten\mchip.\slv.$procmux$537 ($mux).
Removed top 31 bits (of 32) from port B of cell toplevel_chip.$flatten\mchip.\slv.\the_sipo.$add$d11_zhexic_i2cdriver/src/chip.sv:430$47 ($add).
Removed top 28 bits (of 32) from port Y of cell toplevel_chip.$flatten\mchip.\slv.\the_sipo.$add$d11_zhexic_i2cdriver/src/chip.sv:430$47 ($add).
Removed top 31 bits (of 32) from port B of cell toplevel_chip.$flatten\mchip.\slv.\the_piso.$add$d11_zhexic_i2cdriver/src/chip.sv:454$51 ($add).
Removed top 28 bits (of 32) from port Y of cell toplevel_chip.$flatten\mchip.\slv.\the_piso.$add$d11_zhexic_i2cdriver/src/chip.sv:454$51 ($add).
Removed top 2 bits (of 4) from wire toplevel_chip.$flatten\mchip.\slv.$10\nextstate[3:0].
Removed top 1 bits (of 4) from wire toplevel_chip.$flatten\mchip.\slv.$11\nextstate[3:0].
Removed top 1 bits (of 4) from wire toplevel_chip.$flatten\mchip.\slv.$12\nextstate[3:0].
Removed top 1 bits (of 4) from wire toplevel_chip.$flatten\mchip.\slv.$13\nextstate[3:0].
Removed top 3 bits (of 4) from wire toplevel_chip.$flatten\mchip.\slv.$15\nextstate[3:0].
Removed top 2 bits (of 4) from wire toplevel_chip.$flatten\mchip.\slv.$16\nextstate[3:0].
Removed top 3 bits (of 4) from wire toplevel_chip.$flatten\mchip.\slv.$17\nextstate[3:0].
Removed top 3 bits (of 4) from wire toplevel_chip.$flatten\mchip.\slv.$18\nextstate[3:0].
Removed top 3 bits (of 4) from wire toplevel_chip.$flatten\mchip.\slv.$2\nextstate[3:0].
Removed top 1 bits (of 4) from wire toplevel_chip.$flatten\mchip.\slv.$3\nextstate[3:0].
Removed top 1 bits (of 4) from wire toplevel_chip.$flatten\mchip.\slv.$4\nextstate[3:0].
Removed top 1 bits (of 4) from wire toplevel_chip.$flatten\mchip.\slv.$5\nextstate[3:0].
Removed top 1 bits (of 4) from wire toplevel_chip.$flatten\mchip.\slv.$6\nextstate[3:0].
Removed top 2 bits (of 4) from wire toplevel_chip.$flatten\mchip.\slv.$7\nextstate[3:0].
Removed top 1 bits (of 4) from wire toplevel_chip.$flatten\mchip.\slv.$8\nextstate[3:0].
Removed top 28 bits (of 32) from wire toplevel_chip.$flatten\mchip.\slv.\the_sipo.$add$d11_zhexic_i2cdriver/src/chip.sv:430$47_Y.

3.11. Executing PEEPOPT pass (run peephole optimizers).

3.12. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \toplevel_chip..
Removed 0 unused cells and 17 unused wires.
<suppressed ~1 debug messages>

3.13. Executing ALUMACC pass (create $alu and $macc cells).
Extracting $alu and $macc cells in module toplevel_chip:
  creating $macc model for $flatten\mchip.\slv.\the_piso.$add$d11_zhexic_i2cdriver/src/chip.sv:454$51 ($add).
  creating $macc model for $flatten\mchip.\slv.\the_sipo.$add$d11_zhexic_i2cdriver/src/chip.sv:430$47 ($add).
  creating $alu model for $macc $flatten\mchip.\slv.\the_sipo.$add$d11_zhexic_i2cdriver/src/chip.sv:430$47.
  creating $alu model for $macc $flatten\mchip.\slv.\the_piso.$add$d11_zhexic_i2cdriver/src/chip.sv:454$51.
  creating $alu cell for $flatten\mchip.\slv.\the_piso.$add$d11_zhexic_i2cdriver/src/chip.sv:454$51: $auto$alumacc.cc:485:replace_alu$872
  creating $alu cell for $flatten\mchip.\slv.\the_sipo.$add$d11_zhexic_i2cdriver/src/chip.sv:430$47: $auto$alumacc.cc:485:replace_alu$875
  created 2 $alu and 0 $macc cells.

3.14. Executing SHARE pass (SAT-based resource sharing).

3.15. Executing OPT pass (performing simple optimizations).

3.15.1. Executing OPT_EXPR pass (perform const folding).
Optimizing module toplevel_chip.

3.15.2. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\toplevel_chip'.
Removed a total of 0 cells.

3.15.3. Executing OPT_MUXTREE pass (detect dead branches in mux trees).
Running muxtree optimizer on module \toplevel_chip..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Removed 0 multiplexer ports.
<suppressed ~28 debug messages>

3.15.4. Executing OPT_REDUCE pass (consolidate $*mux and $reduce_* inputs).
  Optimizing cells in module \toplevel_chip.
Performed a total of 0 changes.

3.15.5. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\toplevel_chip'.
<suppressed ~9 debug messages>
Removed a total of 3 cells.

3.15.6. Executing OPT_DFF pass (perform DFF optimizations).

3.15.7. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \toplevel_chip..
Removed 0 unused cells and 3 unused wires.
<suppressed ~1 debug messages>

3.15.8. Executing OPT_EXPR pass (perform const folding).
Optimizing module toplevel_chip.

3.15.9. Rerunning OPT passes. (Maybe there is more to do..)

3.15.10. Executing OPT_MUXTREE pass (detect dead branches in mux trees).
Running muxtree optimizer on module \toplevel_chip..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Removed 0 multiplexer ports.
<suppressed ~29 debug messages>

3.15.11. Executing OPT_REDUCE pass (consolidate $*mux and $reduce_* inputs).
  Optimizing cells in module \toplevel_chip.
Performed a total of 0 changes.

3.15.12. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\toplevel_chip'.
Removed a total of 0 cells.

3.15.13. Executing OPT_DFF pass (perform DFF optimizations).

3.15.14. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \toplevel_chip..

3.15.15. Executing OPT_EXPR pass (perform const folding).
Optimizing module toplevel_chip.

3.15.16. Finished OPT passes. (There is nothing left to do.)

3.16. Executing MEMORY pass.

3.16.1. Executing OPT_MEM pass (optimize memories).
Performed a total of 0 transformations.

3.16.2. Executing OPT_MEM_PRIORITY pass (removing unnecessary memory write priority relations).
Performed a total of 0 transformations.

3.16.3. Executing OPT_MEM_FEEDBACK pass (finding memory read-to-write feedback paths).

3.16.4. Executing MEMORY_BMUX2ROM pass (converting muxes to ROMs).

3.16.5. Executing MEMORY_DFF pass (merging $dff cells to $memrd).

3.16.6. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \toplevel_chip..

3.16.7. Executing MEMORY_SHARE pass (consolidating $memrd/$memwr cells).

3.16.8. Executing OPT_MEM_WIDEN pass (optimize memories where all ports are wide).
Performed a total of 0 transformations.

3.16.9. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \toplevel_chip..

3.16.10. Executing MEMORY_COLLECT pass (generating $mem cells).

3.17. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \toplevel_chip..

3.18. Executing OPT pass (performing simple optimizations).

3.18.1. Executing OPT_EXPR pass (perform const folding).
Optimizing module toplevel_chip.
<suppressed ~38 debug messages>

3.18.2. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\toplevel_chip'.
Removed a total of 0 cells.

3.18.3. Executing OPT_DFF pass (perform DFF optimizations).

3.18.4. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \toplevel_chip..
Removed 4 unused cells and 21 unused wires.
<suppressed ~5 debug messages>

3.18.5. Finished fast OPT passes.

3.19. Executing MEMORY_MAP pass (converting memories to logic and flip-flops).

3.20. Executing OPT pass (performing simple optimizations).

3.20.1. Executing OPT_EXPR pass (perform const folding).
Optimizing module toplevel_chip.

3.20.2. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\toplevel_chip'.
Removed a total of 0 cells.

3.20.3. Executing OPT_MUXTREE pass (detect dead branches in mux trees).
Running muxtree optimizer on module \toplevel_chip..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Removed 0 multiplexer ports.
<suppressed ~17 debug messages>

3.20.4. Executing OPT_REDUCE pass (consolidate $*mux and $reduce_* inputs).
  Optimizing cells in module \toplevel_chip.
    Consolidated identical input bits for $mux cell $flatten\mchip.\slv.$procmux$203:
      Old ports: A=4'0111, B=4'1000, Y=$flatten\mchip.\slv.$14\nextstate[3:0]
      New ports: A=2'01, B=2'10, Y={ $flatten\mchip.\slv.$14\nextstate[3:0] [3] $flatten\mchip.\slv.$14\nextstate[3:0] [0] }
      New connections: $flatten\mchip.\slv.$14\nextstate[3:0] [2:1] = { $flatten\mchip.\slv.$14\nextstate[3:0] [0] $flatten\mchip.\slv.$14\nextstate[3:0] [0] }
    Consolidated identical input bits for $mux cell $flatten\mchip.\slv.$procmux$224:
      Old ports: A=3'110, B=3'000, Y=$auto$wreduce.cc:461:run$859 [2:0]
      New ports: A=1'1, B=1'0, Y=$auto$wreduce.cc:461:run$859 [1]
      New connections: { $auto$wreduce.cc:461:run$859 [2] $auto$wreduce.cc:461:run$859 [0] } = { $auto$wreduce.cc:461:run$859 [1] 1'0 }
    Consolidated identical input bits for $mux cell $flatten\mchip.\slv.$procmux$393:
      Old ports: A=3'011, B=3'100, Y=$auto$wreduce.cc:461:run$870 [2:0]
      New ports: A=2'01, B=2'10, Y={ $auto$wreduce.cc:461:run$870 [2] $auto$wreduce.cc:461:run$870 [0] }
      New connections: $auto$wreduce.cc:461:run$870 [1] = $auto$wreduce.cc:461:run$870 [0]
    Consolidated identical input bits for $mux cell $flatten\mchip.\slv.$procmux$422:
      Old ports: A=2'10, B=2'00, Y=$auto$wreduce.cc:461:run$869 [1:0]
      New ports: A=1'1, B=1'0, Y=$auto$wreduce.cc:461:run$869 [1]
      New connections: $auto$wreduce.cc:461:run$869 [0] = 1'0
    Consolidated identical input bits for $mux cell $flatten\mchip.\slv.$procmux$438:
      Old ports: A=3'001, B=3'111, Y=$auto$wreduce.cc:461:run$868 [2:0]
      New ports: A=1'0, B=1'1, Y=$auto$wreduce.cc:461:run$868 [1]
      New connections: { $auto$wreduce.cc:461:run$868 [2] $auto$wreduce.cc:461:run$868 [0] } = { $auto$wreduce.cc:461:run$868 [1] 1'1 }
    Consolidated identical input bits for $mux cell $flatten\mchip.\slv.$procmux$83:
      Old ports: A=4'1011, B=4'0000, Y=$flatten\mchip.\slv.$20\nextstate[3:0]
      New ports: A=1'1, B=1'0, Y=$flatten\mchip.\slv.$20\nextstate[3:0] [0]
      New connections: $flatten\mchip.\slv.$20\nextstate[3:0] [3:1] = { $flatten\mchip.\slv.$20\nextstate[3:0] [0] 1'0 $flatten\mchip.\slv.$20\nextstate[3:0] [0] }
  Optimizing cells in module \toplevel_chip.
    Consolidated identical input bits for $mux cell $flatten\mchip.\slv.$procmux$241:
      Old ports: A=$auto$wreduce.cc:461:run$859 [2:0], B=3'100, Y=$auto$wreduce.cc:461:run$858 [2:0]
      New ports: A={ $auto$wreduce.cc:461:run$859 [1] $auto$wreduce.cc:461:run$859 [1] }, B=2'10, Y=$auto$wreduce.cc:461:run$858 [2:1]
      New connections: $auto$wreduce.cc:461:run$858 [0] = 1'0
    Consolidated identical input bits for $mux cell $flatten\mchip.\slv.$procmux$463:
      Old ports: A=$auto$wreduce.cc:461:run$868 [2:0], B=3'011, Y=$auto$wreduce.cc:461:run$867 [2:0]
      New ports: A={ $auto$wreduce.cc:461:run$868 [1] $auto$wreduce.cc:461:run$868 [1] }, B=2'01, Y=$auto$wreduce.cc:461:run$867 [2:1]
      New connections: $auto$wreduce.cc:461:run$867 [0] = 1'1
    Consolidated identical input bits for $mux cell $flatten\mchip.\slv.$procmux$92:
      Old ports: A=$flatten\mchip.\slv.$20\nextstate[3:0], B=4'1001, Y=$flatten\mchip.\slv.$19\nextstate[3:0]
      New ports: A={ $flatten\mchip.\slv.$20\nextstate[3:0] [0] $flatten\mchip.\slv.$20\nextstate[3:0] [0] }, B=2'01, Y=$flatten\mchip.\slv.$19\nextstate[3:0] [1:0]
      New connections: $flatten\mchip.\slv.$19\nextstate[3:0] [3:2] = { $flatten\mchip.\slv.$19\nextstate[3:0] [0] 1'0 }
  Optimizing cells in module \toplevel_chip.
    Consolidated identical input bits for $mux cell $flatten\mchip.\slv.$procmux$283:
      Old ports: A=$auto$wreduce.cc:461:run$858 [2:0], B=3'110, Y=$auto$wreduce.cc:461:run$857 [2:0]
      New ports: A=$auto$wreduce.cc:461:run$858 [2:1], B=2'11, Y=$auto$wreduce.cc:461:run$857 [2:1]
      New connections: $auto$wreduce.cc:461:run$857 [0] = 1'0
  Optimizing cells in module \toplevel_chip.
Performed a total of 10 changes.

3.20.5. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\toplevel_chip'.
<suppressed ~6 debug messages>
Removed a total of 2 cells.

3.20.6. Executing OPT_SHARE pass.

3.20.7. Executing OPT_DFF pass (perform DFF optimizations).

3.20.8. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \toplevel_chip..
Removed 0 unused cells and 2 unused wires.
<suppressed ~1 debug messages>

3.20.9. Executing OPT_EXPR pass (perform const folding).
Optimizing module toplevel_chip.
<suppressed ~4 debug messages>

3.20.10. Rerunning OPT passes. (Maybe there is more to do..)

3.20.11. Executing OPT_MUXTREE pass (detect dead branches in mux trees).
Running muxtree optimizer on module \toplevel_chip..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Removed 0 multiplexer ports.
<suppressed ~17 debug messages>

3.20.12. Executing OPT_REDUCE pass (consolidate $*mux and $reduce_* inputs).
  Optimizing cells in module \toplevel_chip.
Performed a total of 0 changes.

3.20.13. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\toplevel_chip'.
Removed a total of 0 cells.

3.20.14. Executing OPT_SHARE pass.

3.20.15. Executing OPT_DFF pass (perform DFF optimizations).

3.20.16. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \toplevel_chip..
Removed 0 unused cells and 1 unused wires.
<suppressed ~1 debug messages>

3.20.17. Executing OPT_EXPR pass (perform const folding).
Optimizing module toplevel_chip.

3.20.18. Rerunning OPT passes. (Maybe there is more to do..)

3.20.19. Executing OPT_MUXTREE pass (detect dead branches in mux trees).
Running muxtree optimizer on module \toplevel_chip..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Removed 0 multiplexer ports.
<suppressed ~17 debug messages>

3.20.20. Executing OPT_REDUCE pass (consolidate $*mux and $reduce_* inputs).
  Optimizing cells in module \toplevel_chip.
Performed a total of 0 changes.

3.20.21. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\toplevel_chip'.
Removed a total of 0 cells.

3.20.22. Executing OPT_SHARE pass.

3.20.23. Executing OPT_DFF pass (perform DFF optimizations).

3.20.24. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \toplevel_chip..

3.20.25. Executing OPT_EXPR pass (perform const folding).
Optimizing module toplevel_chip.

3.20.26. Finished OPT passes. (There is nothing left to do.)

3.21. Executing TECHMAP pass (map to technology primitives).

3.21.1. Executing Verilog-2005 frontend: /Users/anish/workspace/oss-cad-suite/libexec/../share/yosys/techmap.v
Parsing Verilog input from `/Users/anish/workspace/oss-cad-suite/libexec/../share/yosys/techmap.v' to AST representation.
Generating RTLIL representation for module `\_90_simplemap_bool_ops'.
Generating RTLIL representation for module `\_90_simplemap_reduce_ops'.
Generating RTLIL representation for module `\_90_simplemap_logic_ops'.
Generating RTLIL representation for module `\_90_simplemap_compare_ops'.
Generating RTLIL representation for module `\_90_simplemap_various'.
Generating RTLIL representation for module `\_90_simplemap_registers'.
Generating RTLIL representation for module `\_90_shift_ops_shr_shl_sshl_sshr'.
Generating RTLIL representation for module `\_90_shift_shiftx'.
Generating RTLIL representation for module `\_90_fa'.
Generating RTLIL representation for module `\_90_lcu'.
Generating RTLIL representation for module `\_90_alu'.
Generating RTLIL representation for module `\_90_macc'.
Generating RTLIL representation for module `\_90_alumacc'.
Generating RTLIL representation for module `\$__div_mod_u'.
Generating RTLIL representation for module `\$__div_mod_trunc'.
Generating RTLIL representation for module `\_90_div'.
Generating RTLIL representation for module `\_90_mod'.
Generating RTLIL representation for module `\$__div_mod_floor'.
Generating RTLIL representation for module `\_90_divfloor'.
Generating RTLIL representation for module `\_90_modfloor'.
Generating RTLIL representation for module `\_90_pow'.
Generating RTLIL representation for module `\_90_pmux'.
Generating RTLIL representation for module `\_90_demux'.
Generating RTLIL representation for module `\_90_lut'.
Successfully finished Verilog frontend.

3.21.2. Continuing TECHMAP pass.
Using extmapper simplemap for cells of type $reduce_or.
Using extmapper simplemap for cells of type $reduce_bool.
Using extmapper simplemap for cells of type $adffe.
Using template $paramod$32a7b7b86c07519b7537abc18e96f0331f97914d\_90_alu for cells of type $alu.
Using extmapper simplemap for cells of type $logic_and.
Using extmapper simplemap for cells of type $and.
Using extmapper simplemap for cells of type $eq.
Using extmapper simplemap for cells of type $mux.
Using extmapper simplemap for cells of type $not.
Using extmapper simplemap for cells of type $or.
Using extmapper simplemap for cells of type $logic_not.
Using template $paramod$1898f562910b1a95b1df10dbe7204af73891130f\_90_pmux for cells of type $pmux.
Using template $paramod$c5c783b17ab1d780abfad8cfe6563a0a7b47a3b0\_90_pmux for cells of type $pmux.
Using template $paramod$d629d85c8826a74239b9178d1930215a43b0ceb0\_90_pmux for cells of type $pmux.
Using extmapper simplemap for cells of type $adff.
Using extmapper simplemap for cells of type $ne.
Using extmapper simplemap for cells of type $xor.
Using template $paramod\_90_lcu\WIDTH=32'00000000000000000000000000000100 for cells of type $lcu.
Using extmapper simplemap for cells of type $pos.
No more expansions possible.
<suppressed ~426 debug messages>

3.22. Executing OPT pass (performing simple optimizations).

3.22.1. Executing OPT_EXPR pass (perform const folding).
Optimizing module toplevel_chip.
<suppressed ~153 debug messages>

3.22.2. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\toplevel_chip'.
<suppressed ~168 debug messages>
Removed a total of 56 cells.

3.22.3. Executing OPT_DFF pass (perform DFF optimizations).

3.22.4. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \toplevel_chip..
Removed 8 unused cells and 244 unused wires.
<suppressed ~9 debug messages>

3.22.5. Finished fast OPT passes.

3.23. Executing ABC pass (technology mapping using ABC).

3.23.1. Extracting gate netlist of module `\toplevel_chip' to `<abc-temp-dir>/input.blif'..
Extracted 239 gates and 285 wires to a netlist network with 44 inputs and 38 outputs.

3.23.1.1. Executing ABC.
Running ABC command: "<yosys-exe-dir>/yosys-abc" -s -f <abc-temp-dir>/abc.script 2>&1
ABC: ABC command line: "source <abc-temp-dir>/abc.script".
ABC: 
ABC: + read_blif <abc-temp-dir>/input.blif 
ABC: + read_library <abc-temp-dir>/stdcells.genlib 
ABC: Entered genlib library with 13 gates from file "<abc-temp-dir>/stdcells.genlib".
ABC: + strash 
ABC: + dretime 
ABC: + map 
ABC: + write_blif <abc-temp-dir>/output.blif 

3.23.1.2. Re-integrating ABC results.
ABC RESULTS:              XNOR cells:        3
ABC RESULTS:               XOR cells:        3
ABC RESULTS:               MUX cells:       12
ABC RESULTS:               NOT cells:        6
ABC RESULTS:               AND cells:        6
ABC RESULTS:              NAND cells:        7
ABC RESULTS:             ORNOT cells:       18
ABC RESULTS:                OR cells:       40
ABC RESULTS:            ANDNOT cells:       76
ABC RESULTS:               NOR cells:       19
ABC RESULTS:        internal signals:      203
ABC RESULTS:           input signals:       44
ABC RESULTS:          output signals:       38
Removing temp directory.

3.24. Executing OPT pass (performing simple optimizations).

3.24.1. Executing OPT_EXPR pass (perform const folding).
Optimizing module toplevel_chip.
<suppressed ~1 debug messages>

3.24.2. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\toplevel_chip'.
Removed a total of 0 cells.

3.24.3. Executing OPT_DFF pass (perform DFF optimizations).

3.24.4. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \toplevel_chip..
Removed 0 unused cells and 189 unused wires.
<suppressed ~24 debug messages>

3.24.5. Finished fast OPT passes.

3.25. Executing HIERARCHY pass (managing design hierarchy).

3.25.1. Analyzing design hierarchy..
Top module:  \toplevel_chip

3.25.2. Analyzing design hierarchy..
Top module:  \toplevel_chip
Removed 0 unused modules.

3.26. Printing statistics.

=== toplevel_chip ===

   Number of wires:                229
   Number of wire bits:            352
   Number of public wires:          50
   Number of public wire bits:     173
   Number of memories:               0
   Number of memory bits:            0
   Number of processes:              0
   Number of cells:                231
     $_ANDNOT_                      76
     $_AND_                          6
     $_DFFE_PN0P_                   32
     $_DFFE_PN1P_                    1
     $_DFF_PN0_                      6
     $_DFF_PN1_                      2
     $_MUX_                         12
     $_NAND_                         7
     $_NOR_                         19
     $_NOT_                          6
     $_ORNOT_                       18
     $_OR_                          40
     $_XNOR_                         3
     $_XOR_                          3

3.27. Executing CHECK pass (checking for obvious problems).
Checking module toplevel_chip...
Found and reported 0 problems.

4. Executing SETUNDEF pass (replace undef values with defined constants).

5. Executing SETUNDEF pass (replace undef values with defined constants).

6. Executing ASYNC2SYNC pass.
Replacing toplevel_chip.$auto$ff.cc:266:slice$1281 ($_DFF_PN1_): ARST=\io_in [13], D=\io_in [1], Q=\mchip.slv.scl_state
Replacing toplevel_chip.$auto$ff.cc:266:slice$1291 ($_DFF_PN0_): ARST=\io_in [13], D=\mchip.slv.nextstate [0], Q=\mchip.slv.state [0]
Replacing toplevel_chip.$auto$ff.cc:266:slice$1292 ($_DFF_PN0_): ARST=\io_in [13], D=\mchip.slv.nextstate [1], Q=\mchip.slv.state [1]
Replacing toplevel_chip.$auto$ff.cc:266:slice$1293 ($_DFF_PN0_): ARST=\io_in [13], D=\mchip.slv.nextstate [2], Q=\mchip.slv.state [2]
Replacing toplevel_chip.$auto$ff.cc:266:slice$1294 ($_DFF_PN0_): ARST=\io_in [13], D=\mchip.slv.nextstate [3], Q=\mchip.slv.state [3]
Replacing toplevel_chip.$auto$ff.cc:266:slice$1295 ($_DFF_PN0_): ARST=\io_in [13], D=\mchip.slv.stop_nextstate, Q=\mchip.slv.stop_state
Replacing toplevel_chip.$auto$ff.cc:266:slice$1299 ($_DFF_PN0_): ARST=\io_in [13], D=\mchip.slv.start_nextstate, Q=\mchip.slv.start_state
Replacing toplevel_chip.$auto$ff.cc:266:slice$1303 ($_DFF_PN1_): ARST=\io_in [13], D=\io_in [0], Q=\mchip.slv.sda_state
Replacing toplevel_chip.$auto$ff.cc:266:slice$1304 ($_DFFE_PN0P_): ARST=\io_in [13], D=$abc$1675$flatten\mchip.\slv.\the_sipo.$0\out[7:0][0], Q=\mchip.slv.the_sipo.out [0]
Replacing toplevel_chip.$auto$ff.cc:266:slice$1305 ($_DFFE_PN0P_): ARST=\io_in [13], D=$abc$1675$flatten\mchip.\slv.\the_sipo.$0\out[7:0][1], Q=\mchip.slv.the_sipo.out [1]
Replacing toplevel_chip.$auto$ff.cc:266:slice$1306 ($_DFFE_PN0P_): ARST=\io_in [13], D=$abc$1675$flatten\mchip.\slv.\the_sipo.$0\out[7:0][2], Q=\mchip.slv.the_sipo.out [2]
Replacing toplevel_chip.$auto$ff.cc:266:slice$1307 ($_DFFE_PN0P_): ARST=\io_in [13], D=$abc$1675$flatten\mchip.\slv.\the_sipo.$0\out[7:0][3], Q=\mchip.slv.the_sipo.out [3]
Replacing toplevel_chip.$auto$ff.cc:266:slice$1308 ($_DFFE_PN0P_): ARST=\io_in [13], D=$abc$1675$flatten\mchip.\slv.\the_sipo.$0\out[7:0][4], Q=\mchip.slv.the_sipo.out [4]
Replacing toplevel_chip.$auto$ff.cc:266:slice$1309 ($_DFFE_PN0P_): ARST=\io_in [13], D=$abc$1675$flatten\mchip.\slv.\the_sipo.$0\out[7:0][5], Q=\mchip.slv.the_sipo.out [5]
Replacing toplevel_chip.$auto$ff.cc:266:slice$1310 ($_DFFE_PN0P_): ARST=\io_in [13], D=$abc$1675$flatten\mchip.\slv.\the_sipo.$0\out[7:0][6], Q=\mchip.slv.the_sipo.out [6]
Replacing toplevel_chip.$auto$ff.cc:266:slice$1311 ($_DFFE_PN0P_): ARST=\io_in [13], D=$abc$1675$flatten\mchip.\slv.\the_sipo.$0\out[7:0][7], Q=\mchip.slv.the_sipo.out [7]
Replacing toplevel_chip.$auto$ff.cc:266:slice$1312 ($_DFFE_PN0P_): ARST=\io_in [13], D=\mchip.slv.the_sipo.out [0], Q=\mchip.slv.the_reg.out [0]
Replacing toplevel_chip.$auto$ff.cc:266:slice$1313 ($_DFFE_PN0P_): ARST=\io_in [13], D=\mchip.slv.the_sipo.out [1], Q=\mchip.slv.the_reg.out [1]
Replacing toplevel_chip.$auto$ff.cc:266:slice$1314 ($_DFFE_PN0P_): ARST=\io_in [13], D=\mchip.slv.the_sipo.out [2], Q=\mchip.slv.the_reg.out [2]
Replacing toplevel_chip.$auto$ff.cc:266:slice$1315 ($_DFFE_PN0P_): ARST=\io_in [13], D=\mchip.slv.the_sipo.out [3], Q=\mchip.slv.the_reg.out [3]
Replacing toplevel_chip.$auto$ff.cc:266:slice$1316 ($_DFFE_PN0P_): ARST=\io_in [13], D=\mchip.slv.the_sipo.out [4], Q=\mchip.slv.the_reg.out [4]
Replacing toplevel_chip.$auto$ff.cc:266:slice$1317 ($_DFFE_PN0P_): ARST=\io_in [13], D=\mchip.slv.the_sipo.out [5], Q=\mchip.slv.the_reg.out [5]
Replacing toplevel_chip.$auto$ff.cc:266:slice$1318 ($_DFFE_PN0P_): ARST=\io_in [13], D=\mchip.slv.the_sipo.out [6], Q=\mchip.slv.the_reg.out [6]
Replacing toplevel_chip.$auto$ff.cc:266:slice$1319 ($_DFFE_PN0P_): ARST=\io_in [13], D=\mchip.slv.the_sipo.out [7], Q=\mchip.slv.the_reg.out [7]
Replacing toplevel_chip.$auto$ff.cc:266:slice$1345 ($_DFFE_PN0P_): ARST=\io_in [13], D=$abc$1675$flatten\mchip.\slv.\the_piso.$0\register[7:0][0], Q=\mchip.slv.the_piso.register [0]
Replacing toplevel_chip.$auto$ff.cc:266:slice$1346 ($_DFFE_PN0P_): ARST=\io_in [13], D=$abc$1675$flatten\mchip.\slv.\the_piso.$0\register[7:0][1], Q=\mchip.slv.the_piso.register [1]
Replacing toplevel_chip.$auto$ff.cc:266:slice$1347 ($_DFFE_PN0P_): ARST=\io_in [13], D=$abc$1675$flatten\mchip.\slv.\the_piso.$0\register[7:0][2], Q=\mchip.slv.the_piso.register [2]
Replacing toplevel_chip.$auto$ff.cc:266:slice$1348 ($_DFFE_PN0P_): ARST=\io_in [13], D=$abc$1675$flatten\mchip.\slv.\the_piso.$0\register[7:0][3], Q=\mchip.slv.the_piso.register [3]
Replacing toplevel_chip.$auto$ff.cc:266:slice$1349 ($_DFFE_PN0P_): ARST=\io_in [13], D=$abc$1675$flatten\mchip.\slv.\the_piso.$0\register[7:0][4], Q=\mchip.slv.the_piso.register [4]
Replacing toplevel_chip.$auto$ff.cc:266:slice$1350 ($_DFFE_PN0P_): ARST=\io_in [13], D=$abc$1675$flatten\mchip.\slv.\the_piso.$0\register[7:0][5], Q=\mchip.slv.the_piso.register [5]
Replacing toplevel_chip.$auto$ff.cc:266:slice$1351 ($_DFFE_PN0P_): ARST=\io_in [13], D=$abc$1675$flatten\mchip.\slv.\the_piso.$0\register[7:0][6], Q=\mchip.slv.the_piso.register [6]
Replacing toplevel_chip.$auto$ff.cc:266:slice$1352 ($_DFFE_PN0P_): ARST=\io_in [13], D=$abc$1675$flatten\mchip.\slv.\the_piso.$0\register[7:0][7], Q=\mchip.slv.the_piso.register [7]
Replacing toplevel_chip.$auto$ff.cc:266:slice$1353 ($_DFFE_PN0P_): ARST=\io_in [13], D=$abc$1675$flatten\mchip.\slv.\the_piso.$0\counter[3:0][0], Q=\mchip.slv.the_piso.counter [0]
Replacing toplevel_chip.$auto$ff.cc:266:slice$1354 ($_DFFE_PN0P_): ARST=\io_in [13], D=$abc$1675$flatten\mchip.\slv.\the_piso.$0\counter[3:0][1], Q=\mchip.slv.the_piso.counter [1]
Replacing toplevel_chip.$auto$ff.cc:266:slice$1355 ($_DFFE_PN0P_): ARST=\io_in [13], D=$abc$1675$flatten\mchip.\slv.\the_piso.$0\counter[3:0][2], Q=\mchip.slv.the_piso.counter [2]
Replacing toplevel_chip.$auto$ff.cc:266:slice$1356 ($_DFFE_PN1P_): ARST=\io_in [13], D=$abc$1675$flatten\mchip.\slv.\the_piso.$0\counter[3:0][3], Q=\mchip.slv.the_piso.counter [3]
Replacing toplevel_chip.$auto$ff.cc:266:slice$1357 ($_DFFE_PN0P_): ARST=\io_in [13], D=$abc$1675$flatten\mchip.\slv.\the_piso.$0\out[0:0], Q=\mchip.slv.the_piso.out
Replacing toplevel_chip.$auto$ff.cc:266:slice$961 ($_DFFE_PN0P_): ARST=\io_in [13], D=$abc$1675$flatten\mchip.\slv.\the_sipo.$0\counter[3:0][0], Q=\mchip.slv.the_sipo.counter [0]
Replacing toplevel_chip.$auto$ff.cc:266:slice$962 ($_DFFE_PN0P_): ARST=\io_in [13], D=$abc$1675$flatten\mchip.\slv.\the_sipo.$0\counter[3:0][1], Q=\mchip.slv.the_sipo.counter [1]
Replacing toplevel_chip.$auto$ff.cc:266:slice$963 ($_DFFE_PN0P_): ARST=\io_in [13], D=$abc$1675$flatten\mchip.\slv.\the_sipo.$0\counter[3:0][2], Q=\mchip.slv.the_sipo.counter [2]
Replacing toplevel_chip.$auto$ff.cc:266:slice$964 ($_DFFE_PN0P_): ARST=\io_in [13], D=$abc$1675$flatten\mchip.\slv.\the_sipo.$0\counter[3:0][3], Q=\mchip.slv.the_sipo.counter [3]

7. Executing SYNTH pass.

7.1. Executing HIERARCHY pass (managing design hierarchy).

7.1.1. Analyzing design hierarchy..
Top module:  \toplevel_chip

7.1.2. Analyzing design hierarchy..
Top module:  \toplevel_chip
Removed 0 unused modules.

7.2. Executing PROC pass (convert processes to netlists).

7.2.1. Executing PROC_CLEAN pass (remove empty switches from decision trees).
Cleaned up 0 empty switches.

7.2.2. Executing PROC_RMDEAD pass (remove dead branches from decision trees).
Removed a total of 0 dead cases.

7.2.3. Executing PROC_PRUNE pass (remove redundant assignments in processes).
Removed 0 redundant assignments.
Promoted 0 assignments to connections.

7.2.4. Executing PROC_INIT pass (extract init attributes).

7.2.5. Executing PROC_ARST pass (detect async resets in processes).

7.2.6. Executing PROC_ROM pass (convert switches to ROMs).
Converted 0 switches.

7.2.7. Executing PROC_MUX pass (convert decision trees to multiplexers).

7.2.8. Executing PROC_DLATCH pass (convert process syncs to latches).

7.2.9. Executing PROC_DFF pass (convert process syncs to FFs).

7.2.10. Executing PROC_MEMWR pass (convert process memory writes to cells).

7.2.11. Executing PROC_CLEAN pass (remove empty switches from decision trees).
Cleaned up 0 empty switches.

7.2.12. Executing OPT_EXPR pass (perform const folding).
Optimizing module toplevel_chip.

7.3. Executing OPT_EXPR pass (perform const folding).
Optimizing module toplevel_chip.

7.4. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \toplevel_chip..

7.5. Executing CHECK pass (checking for obvious problems).
Checking module toplevel_chip...
Found and reported 0 problems.

7.6. Executing OPT pass (performing simple optimizations).

7.6.1. Executing OPT_EXPR pass (perform const folding).
Optimizing module toplevel_chip.

7.6.2. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\toplevel_chip'.
Removed a total of 0 cells.

7.6.3. Executing OPT_MUXTREE pass (detect dead branches in mux trees).
Running muxtree optimizer on module \toplevel_chip..
  Creating internal representation of mux trees.
  No muxes found in this module.
Removed 0 multiplexer ports.

7.6.4. Executing OPT_REDUCE pass (consolidate $*mux and $reduce_* inputs).
  Optimizing cells in module \toplevel_chip.
Performed a total of 0 changes.

7.6.5. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\toplevel_chip'.
Removed a total of 0 cells.

7.6.6. Executing OPT_DFF pass (perform DFF optimizations).

7.6.7. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \toplevel_chip..

7.6.8. Executing OPT_EXPR pass (perform const folding).
Optimizing module toplevel_chip.

7.6.9. Finished OPT passes. (There is nothing left to do.)

7.7. Executing FSM pass (extract and optimize FSM).

7.7.1. Executing FSM_DETECT pass (finding FSMs in design).

7.7.2. Executing FSM_EXTRACT pass (extracting FSM from design).

7.7.3. Executing FSM_OPT pass (simple optimizations of FSMs).

7.7.4. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \toplevel_chip..

7.7.5. Executing FSM_OPT pass (simple optimizations of FSMs).

7.7.6. Executing FSM_RECODE pass (re-assigning FSM state encoding).

7.7.7. Executing FSM_INFO pass (dumping all available information on FSM cells).

7.7.8. Executing FSM_MAP pass (mapping FSMs to basic logic).

7.8. Executing OPT pass (performing simple optimizations).

7.8.1. Executing OPT_EXPR pass (perform const folding).
Optimizing module toplevel_chip.

7.8.2. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\toplevel_chip'.
Removed a total of 0 cells.

7.8.3. Executing OPT_MUXTREE pass (detect dead branches in mux trees).
Running muxtree optimizer on module \toplevel_chip..
  Creating internal representation of mux trees.
  No muxes found in this module.
Removed 0 multiplexer ports.

7.8.4. Executing OPT_REDUCE pass (consolidate $*mux and $reduce_* inputs).
  Optimizing cells in module \toplevel_chip.
Performed a total of 0 changes.

7.8.5. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\toplevel_chip'.
Removed a total of 0 cells.

7.8.6. Executing OPT_DFF pass (perform DFF optimizations).

7.8.7. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \toplevel_chip..

7.8.8. Executing OPT_EXPR pass (perform const folding).
Optimizing module toplevel_chip.

7.8.9. Finished OPT passes. (There is nothing left to do.)

7.9. Executing WREDUCE pass (reducing word size of cells).

7.10. Executing PEEPOPT pass (run peephole optimizers).

7.11. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \toplevel_chip..

7.12. Executing ALUMACC pass (create $alu and $macc cells).
Extracting $alu and $macc cells in module toplevel_chip:
  created 0 $alu and 0 $macc cells.

7.13. Executing SHARE pass (SAT-based resource sharing).

7.14. Executing OPT pass (performing simple optimizations).

7.14.1. Executing OPT_EXPR pass (perform const folding).
Optimizing module toplevel_chip.

7.14.2. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\toplevel_chip'.
Removed a total of 0 cells.

7.14.3. Executing OPT_MUXTREE pass (detect dead branches in mux trees).
Running muxtree optimizer on module \toplevel_chip..
  Creating internal representation of mux trees.
  No muxes found in this module.
Removed 0 multiplexer ports.

7.14.4. Executing OPT_REDUCE pass (consolidate $*mux and $reduce_* inputs).
  Optimizing cells in module \toplevel_chip.
Performed a total of 0 changes.

7.14.5. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\toplevel_chip'.
Removed a total of 0 cells.

7.14.6. Executing OPT_DFF pass (perform DFF optimizations).

7.14.7. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \toplevel_chip..

7.14.8. Executing OPT_EXPR pass (perform const folding).
Optimizing module toplevel_chip.

7.14.9. Finished OPT passes. (There is nothing left to do.)

7.15. Executing MEMORY pass.

7.15.1. Executing OPT_MEM pass (optimize memories).
Performed a total of 0 transformations.

7.15.2. Executing OPT_MEM_PRIORITY pass (removing unnecessary memory write priority relations).
Performed a total of 0 transformations.

7.15.3. Executing OPT_MEM_FEEDBACK pass (finding memory read-to-write feedback paths).

7.15.4. Executing MEMORY_BMUX2ROM pass (converting muxes to ROMs).

7.15.5. Executing MEMORY_DFF pass (merging $dff cells to $memrd).

7.15.6. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \toplevel_chip..

7.15.7. Executing MEMORY_SHARE pass (consolidating $memrd/$memwr cells).

7.15.8. Executing OPT_MEM_WIDEN pass (optimize memories where all ports are wide).
Performed a total of 0 transformations.

7.15.9. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \toplevel_chip..

7.15.10. Executing MEMORY_COLLECT pass (generating $mem cells).

7.16. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \toplevel_chip..

7.17. Executing OPT pass (performing simple optimizations).

7.17.1. Executing OPT_EXPR pass (perform const folding).
Optimizing module toplevel_chip.
<suppressed ~38 debug messages>

7.17.2. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\toplevel_chip'.
Removed a total of 0 cells.

7.17.3. Executing OPT_DFF pass (perform DFF optimizations).

7.17.4. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \toplevel_chip..

7.17.5. Finished fast OPT passes.

7.18. Executing MEMORY_MAP pass (converting memories to logic and flip-flops).

7.19. Executing OPT pass (performing simple optimizations).

7.19.1. Executing OPT_EXPR pass (perform const folding).
Optimizing module toplevel_chip.

7.19.2. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\toplevel_chip'.
Removed a total of 0 cells.

7.19.3. Executing OPT_MUXTREE pass (detect dead branches in mux trees).
Running muxtree optimizer on module \toplevel_chip..
  Creating internal representation of mux trees.
  No muxes found in this module.
Removed 0 multiplexer ports.

7.19.4. Executing OPT_REDUCE pass (consolidate $*mux and $reduce_* inputs).
  Optimizing cells in module \toplevel_chip.
Performed a total of 0 changes.

7.19.5. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\toplevel_chip'.
Removed a total of 0 cells.

7.19.6. Executing OPT_SHARE pass.

7.19.7. Executing OPT_DFF pass (perform DFF optimizations).

7.19.8. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \toplevel_chip..

7.19.9. Executing OPT_EXPR pass (perform const folding).
Optimizing module toplevel_chip.

7.19.10. Finished OPT passes. (There is nothing left to do.)

7.20. Executing TECHMAP pass (map to technology primitives).

7.20.1. Executing Verilog-2005 frontend: /Users/anish/workspace/oss-cad-suite/libexec/../share/yosys/techmap.v
Parsing Verilog input from `/Users/anish/workspace/oss-cad-suite/libexec/../share/yosys/techmap.v' to AST representation.
Generating RTLIL representation for module `\_90_simplemap_bool_ops'.
Generating RTLIL representation for module `\_90_simplemap_reduce_ops'.
Generating RTLIL representation for module `\_90_simplemap_logic_ops'.
Generating RTLIL representation for module `\_90_simplemap_compare_ops'.
Generating RTLIL representation for module `\_90_simplemap_various'.
Generating RTLIL representation for module `\_90_simplemap_registers'.
Generating RTLIL representation for module `\_90_shift_ops_shr_shl_sshl_sshr'.
Generating RTLIL representation for module `\_90_shift_shiftx'.
Generating RTLIL representation for module `\_90_fa'.
Generating RTLIL representation for module `\_90_lcu'.
Generating RTLIL representation for module `\_90_alu'.
Generating RTLIL representation for module `\_90_macc'.
Generating RTLIL representation for module `\_90_alumacc'.
Generating RTLIL representation for module `\$__div_mod_u'.
Generating RTLIL representation for module `\$__div_mod_trunc'.
Generating RTLIL representation for module `\_90_div'.
Generating RTLIL representation for module `\_90_mod'.
Generating RTLIL representation for module `\$__div_mod_floor'.
Generating RTLIL representation for module `\_90_divfloor'.
Generating RTLIL representation for module `\_90_modfloor'.
Generating RTLIL representation for module `\_90_pow'.
Generating RTLIL representation for module `\_90_pmux'.
Generating RTLIL representation for module `\_90_demux'.
Generating RTLIL representation for module `\_90_lut'.
Successfully finished Verilog frontend.

7.20.2. Continuing TECHMAP pass.
No more expansions possible.
<suppressed ~73 debug messages>

7.21. Executing OPT pass (performing simple optimizations).

7.21.1. Executing OPT_EXPR pass (perform const folding).
Optimizing module toplevel_chip.

7.21.2. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\toplevel_chip'.
Removed a total of 0 cells.

7.21.3. Executing OPT_DFF pass (perform DFF optimizations).

7.21.4. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \toplevel_chip..

7.21.5. Finished fast OPT passes.

7.22. Executing ABC pass (technology mapping using ABC).

7.22.1. Extracting gate netlist of module `\toplevel_chip' to `<abc-temp-dir>/input.blif'..
Extracted 231 gates and 285 wires to a netlist network with 53 inputs and 54 outputs.

7.22.1.1. Executing ABC.
Running ABC command: "<yosys-exe-dir>/yosys-abc" -s -f <abc-temp-dir>/abc.script 2>&1
ABC: ABC command line: "source <abc-temp-dir>/abc.script".
ABC: 
ABC: + read_blif <abc-temp-dir>/input.blif 
ABC: + read_library <abc-temp-dir>/stdcells.genlib 
ABC: Entered genlib library with 13 gates from file "<abc-temp-dir>/stdcells.genlib".
ABC: + strash 
ABC: + dretime 
ABC: + map 
ABC: + write_blif <abc-temp-dir>/output.blif 

7.22.1.2. Re-integrating ABC results.
ABC RESULTS:               XOR cells:        5
ABC RESULTS:               NOT cells:        9
ABC RESULTS:               MUX cells:       13
ABC RESULTS:              NAND cells:       13
ABC RESULTS:             ORNOT cells:       10
ABC RESULTS:                OR cells:       48
ABC RESULTS:            ANDNOT cells:       71
ABC RESULTS:               NOR cells:       19
ABC RESULTS:               AND cells:       42
ABC RESULTS:        internal signals:      178
ABC RESULTS:           input signals:       53
ABC RESULTS:          output signals:       54
Removing temp directory.

7.23. Executing OPT pass (performing simple optimizations).

7.23.1. Executing OPT_EXPR pass (perform const folding).
Optimizing module toplevel_chip.
<suppressed ~1 debug messages>

7.23.2. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\toplevel_chip'.
Removed a total of 0 cells.

7.23.3. Executing OPT_DFF pass (perform DFF optimizations).

7.23.4. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \toplevel_chip..
Removed 0 unused cells and 269 unused wires.
<suppressed ~11 debug messages>

7.23.5. Finished fast OPT passes.

7.24. Executing HIERARCHY pass (managing design hierarchy).

7.24.1. Analyzing design hierarchy..
Top module:  \toplevel_chip

7.24.2. Analyzing design hierarchy..
Top module:  \toplevel_chip
Removed 0 unused modules.

7.25. Printing statistics.

=== toplevel_chip ===

   Number of wires:                284
   Number of wire bits:            391
   Number of public wires:          40
   Number of public wire bits:     147
   Number of memories:               0
   Number of memory bits:            0
   Number of processes:              0
   Number of cells:                271
     $_ANDNOT_                      71
     $_AND_                         42
     $_MUX_                         13
     $_NAND_                        13
     $_NOR_                         19
     $_NOT_                          9
     $_ORNOT_                       10
     $_OR_                          48
     $_SDFFE_PN0P_                  32
     $_SDFFE_PN1P_                   1
     $_SDFF_PN0_                     6
     $_SDFF_PN1_                     2
     $_XOR_                          5

7.26. Executing CHECK pass (checking for obvious problems).
Checking module toplevel_chip...
Found and reported 0 problems.
Renaming module \toplevel_chip to \d11_zhexic_i2cdriver.

8. Executing Verilog backend.

8.1. Executing BMUXMAP pass.

8.2. Executing DEMUXMAP pass.
Dumping module `\d11_zhexic_i2cdriver'.

9. Executing CHECK pass (checking for obvious problems).
Checking module d11_zhexic_i2cdriver...
Found and reported 0 problems.

10. Printing statistics.

=== d11_zhexic_i2cdriver ===

   Number of wires:                284
   Number of wire bits:            391
   Number of public wires:          40
   Number of public wire bits:     147
   Number of memories:               0
   Number of memory bits:            0
   Number of processes:              0
   Number of cells:                271
     $_ANDNOT_                      71
     $_AND_                         42
     $_MUX_                         13
     $_NAND_                        13
     $_NOR_                         19
     $_NOT_                          9
     $_ORNOT_                       10
     $_OR_                          48
     $_SDFFE_PN0P_                  32
     $_SDFFE_PN1P_                   1
     $_SDFF_PN0_                     6
     $_SDFF_PN1_                     2
     $_XOR_                          5

End of script. Logfile hash: 2b1f0d60a8, CPU: user 0.25s system 0.01s
Yosys 0.36+3 (git sha1 a53032104, aarch64-apple-darwin20.2-clang 10.0.0-4ubuntu1 -fPIC -Os)
Time spent: 32% 2x abc (0 sec), 19% 36x opt_expr (0 sec), ...

